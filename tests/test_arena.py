from pkmn_rl_arena import (
    ROM_PATH,
    BIOS_PATH,
    MAP_PATH,
)
from pkmn_rl_arena import logger
from pkmn_rl_arena.env.battle_core import BattleCore, TurnType
from pkmn_rl_arena.env.battle_arena import BattleArena
from pkmn_rl_arena.env.pkmn_team_factory import DataSize
from pkmn_rl_arena.data import pokemon_data

from pettingzoo.test import parallel_api_test

import unittest
import picologging as logging

from typing import Dict


class TestArena(unittest.TestCase):
    def setUp(self):
        logger.setLevel(logging.DEBUG)
        core = BattleCore(ROM_PATH, BIOS_PATH, MAP_PATH)
        self.arena = BattleArena(core)
        self.required_agents = self.arena.battle_state.get_required_agents()

    def tearDown(self):
        BattleArena.close()

    def test_step(self):
        for agent in self.arena.battle_state.get_required_agents():
            observation, reward, termination, truncation, info = self.arena.last()

            if termination or truncation:
                action = None
            else:
                # insert neural network here to choose action from observation space
                #
                # until then here is a dummy fctn
                action[agent] = self.arena.action_space(agent).sample()

        self.arena.step(action)

    def test_reset(self):
        required_agents = self.arena.battle_state.get_required_agents()
        action: Dict[str, int] | None = {} if required_agents == [] else None

        for agent in required_agents:
            observation, reward, termination, truncation, info = self.arena.last()

            if not (termination or truncation):
                action = None
                break
            else:
                # insert neural network here to choose action from observation space
                #
                # until then here is a dummy fctn
                action[agent] = self.arena.action_space(agent).sample()

        self.arena.step(action)
        self.arena.reset()

    # def test_load_save_state():
    #     pass

    # def test_render(self):
    #     self.arena.reset(seed=42)
    #     self.arena.render()


class TestPettingZooAPI(unittest.TestCase):
    def setUp(self):
        logger.setLevel(logging.DEBUG)
        core = BattleCore(ROM_PATH, BIOS_PATH, MAP_PATH)
        self.arena = BattleArena(core)

    def test(self):
        parallel_api_test(self.arena, num_cycles=1000)

    def tearDown(self):
        BattleArena.close()


class TestResetOptions(unittest.TestCase):
    def setUp(self):
        logger.setLevel(logging.DEBUG)
        core = BattleCore(ROM_PATH, BIOS_PATH, MAP_PATH)
        self.arena = BattleArena(core)
        self.required_agents = self.arena.battle_state.get_required_agents()

    def tearDown(self):
        BattleArena.close()

    def test_load_savestate(self):
        """
        Testing :
            1. Generate random team data (8*6 params)
            2. Writes it to gba
            5. Read pkmn teams data generated by the game from pkmn params
            6. Ensures data matches grondtruth

        Functions called:
            - PkmnTeamFactory.Create_random_team()
            - BattleArena.reset() with a random generated team()
            - pkmn_data.to_pandas_team_dump_data()
            - BattleArena.create_teams()

        Ground Truth :
            - Team generated with team_factory
        """
        options = {
            "save_state": "boot_state",
        }
        self.arena.reset(options=options)
        self.assertEqual(self.arena.battle_state.current_turn, TurnType.GENERAL)
        return

    def test_create_team(self):
        """
        Testing :
            1. Generate random team data (8*6 params)
            2. Writes it to gba
            5. Read pkmn teams data generated by the game from pkmn params
            6. Ensures data matches grondtruth

        Functions called:
            - PkmnTeamFactory.Create_random_team()
            - BattleArena.reset() with a random generated team()
            - pkmn_data.to_pandas_team_dump_data()
            - BattleArena.create_teams()

        Ground Truth :
            - Team generated with team_factory
        """
        options = {
            "teams": {
                "player": self.arena.team_factory.create_random_team(),
                "enemy": self.arena.team_factory.create_random_team(),
            },
        }
        self.arena.reset(options=options)
        self.assertEqual(self.arena.battle_state.current_turn, TurnType.GENERAL)

        for agent in self.arena.possible_agents:
            ground_truth_team_params = options["teams"][agent]

            gba_read_team_data = self.arena.core.read_team_data(agent)
            gba_read_team_df = pokemon_data.to_pandas_team_dump_data(gba_read_team_data)

            for i in range(6):
                start = i * DataSize.PKMN
                self.assertEqual(
                    gba_read_team_df.iloc[i]["id"],
                    ground_truth_team_params[start],
                    f"{agent} team ID mismatch at pokemon {i}.",
                )
                self.assertEqual(
                    gba_read_team_df.iloc[i]["level"],
                    ground_truth_team_params[start + 1],
                    f"{agent} team level mismatch at pokemon {i}.",
                )
                self.assertEqual(
                    gba_read_team_df.iloc[i]["moves"],
                    ground_truth_team_params[start + 2 : start + 6],
                    f"{agent} team moves mismatch at pokemon {i}.",
                )
                self.assertEqual(
                    gba_read_team_df.iloc[i]["held_item"],
                    ground_truth_team_params[start + 7],
                    f"{agent} team item mismatch at pokemon {i}.",
                )

    def test_reset_with_invalid_pkmn_params(self):
        """
        Trying to create a squirtle with GROWL even if its not in squirtle movepool
        """
        options = {
            "save_state": "boot_state",
            "teams": {
                "player": [
                    7,
                    2,
                    45,
                    45,
                    45,
                    45,
                    10,
                    0,
                ],
                "enemy": None,
            },
        }

        # This test case Pikachu has 100% chance to faint
        with self.assertRaises(ValueError) as context_manager:
            self.arena.reset(options=options)
        self.assertEqual(
            str(context_manager.exception), 'Invalid reset param : "team".'
        )


class TestFightUnfold(unittest.TestCase):
    """
    The following tests writes directly actions using the action_manager to test

    Its purpose is to test the action manager as well as other lower level apis.

    NOTE: Should be refactored to not use BattleArena nor PkmnRLCore
    """

    def setUp(self):
        logger.setLevel(logging.DEBUG)
        core = BattleCore(ROM_PATH, BIOS_PATH, MAP_PATH)
        self.arena = BattleArena(core)

    def tearDown(self):
        BattleArena.close()

    def test_enemy_lost(self):
        # pikachu lvl 99 using shock wave (86) with 100% accyracy
        options = {
            "save_state": "boot_state",
            "teams": {
                # Pikachu with moves and 100% HP
                "player": [
                    25,
                    99,
                    84,
                    84,
                    84,
                    84,
                    100,
                    0,
                ],
                # Magikarp uses splash wich does nothing 10% HP
                "enemy": [
                    129,
                    10,
                    150,
                    0,
                    0,
                    0,
                    10,
                    0,
                ],
            },
        }

        self.arena.reset(options)
        self.arena.step()

        for agent in self.arena.possible_agents:
            self.assertTrue(self.arena.terminations[agent])

    def test_switch_pokemon(self):
        options = {
            "save_state": "boot_state",
            "teams": {
                "player": [
                    129,  # Magikarp lvl 1 with splash wich does nothing
                    1,  # lvl 1
                    150,  # splash
                    0,
                    0,
                    0,
                    100,  # 100% hp
                    0,
                ],
                "enemy": [
                    # Squirtle
                    7,
                    99,  # lvl 99
                    111,  # DEFENSE CURL
                    0,
                    0,
                    0,
                    10,  # 10 % hp
                    0,
                    # WARTORTLE
                    8,
                    99,
                    5,  # MEGAPUNCH
                    5,  # MEGAPUNCH
                    5,  # MEGAPUNCH
                    5,  # MEGAPUNCH
                    11,
                    0,
                ],
            },
        }

        self.arena.reset(options=options)

        player_action = 0  # use move defense curl
        enemy_action = 5  #
        actions = {"player": player_action, "enemy": enemy_action}

        self.arena.action_manager.write_actions(
            self.arena.battle_state.current_turn, actions
        )
        turn = self.arena.core.advance_to_next_turn()
        self.assertEqual(turn, TurnType.GENERAL)

        enemy_team_dump_data = self.arena.core.read_team_data("enemy")

        enemydf = pokemon_data.to_pandas_team_dump_data(enemy_team_dump_data)
        active_enemy = enemydf[enemydf["isActive"] == 1]
        print(enemydf)
        self.assertEqual(
            len(active_enemy),
            1,
            "There should be exactly one active Pokémon in the enemy team.",
        )
        self.assertEqual(
            active_enemy.iloc[0]["id"],
            8,
            "The active Pokémon in the enemy team should have ID 8.",
        )

    def test_invalid_action(self):
        options = {
            "save_state": "boot_state",
            "teams": {
                "player": [
                    # SQUIRTLE
                    7,
                    2,  # lvl 2
                    5,
                    5,
                    5,
                    5,
                    10,
                    0,
                    # RAICHU
                    26,
                    10,
                    5,
                    5,
                    5,
                    5,
                    100,
                    0,
                ],
                "enemy": [
                    25,  # pikachu
                    50,
                    84,  # Thunderschock
                    84,
                    84,
                    84,
                    100,  # %HP
                    0,
                ],
            },
        }

        # This test case Pikachu has 100% chance to faint
        self.arena.reset(options=options)

        # Both use first move (Pikachu will faint)
        player_action = 0
        enemy_action = 0
        actions = {"player": player_action, "enemy": enemy_action}

        self.arena.action_manager.write_actions(
            self.arena.battle_state.current_turn, actions
        )

        turn = self.arena.core.advance_to_next_turn()
        self.assertEqual(turn, TurnType.PLAYER)
        player_action = 5  # Switch with the [1] mon (Bulbasaur)
        actions = {"player": player_action}
        written_actions = self.arena.action_manager.write_actions(turn, actions)
        self.assertFalse(
            written_actions["enemy"],
            "Invalid action written successfully! This should not happen.",
        )

    def test_switch_pokemon_when_one_fainted_player(self):
        options = {
            "save_state": "boot_state",
            "teams": {
                "player": [
                    # SQUIRTLE
                    7,
                    2,  # lvl 2
                    5,
                    5,
                    5,
                    5,
                    10,
                    0,
                    # RAICHU
                    26,
                    10,
                    5,
                    5,
                    5,
                    5,
                    100,
                    0,
                ],
                "enemy": [
                    25,  # pikachu
                    50,
                    84,  # Thunderschock
                    84,
                    84,
                    84,
                    100,  # %HP
                    0,
                ],
            },
        }

        # This test case Pikachu has 100% chance to faint
        self.arena.reset(options=options)

        # Both use first move (Pikachu will faint)
        actions = {"player": 0, "enemy": 0}

        for agent, result in self.arena.action_manager.write_actions(
            self.arena.battle_state.current_turn, actions
        ).items():
            self.assertTrue(result, "Valid action not written this should not happen.")

        turn = self.arena.core.advance_to_next_turn()
        self.assertEqual(turn, TurnType.PLAYER)

        actions = {"player": 5}  # Switch with the [1] mon (RAICHU)}
        for agent, result in self.arena.action_manager.write_actions(
            self.arena.battle_state.current_turn, actions
        ).items():
            self.assertTrue(result, "Valid action not written this should not happen.")

        turn = self.arena.core.advance_to_next_turn()
        self.assertEqual(turn, TurnType.GENERAL)

        player_team_dump_data = self.arena.core.read_team_data("player")
        playerdf = pokemon_data.to_pandas_team_dump_data(player_team_dump_data)
        active_player = playerdf[playerdf["isActive"] == 1]
        self.assertEqual(
            len(active_player),
            1,
            "There should be exactly one active Pokémon in the player team.",
        )
        self.assertEqual(
            active_player.iloc[0]["id"],
            26,
            "The active Pokémon in the player team should have ID 26.",
        )

    # def test_special_moves():
    #     #ROAR FLEE FLY MULTIMOVE MULTIHIT ENCORE move 5 also
    #     pass
    # def test_status():
    #     pass

    # def test_all_moves():
    #     # # Test all moves
    #     pass


if __name__ == "__main__":
    suite = unittest.TestSuite()
